BASIC-1978
==========

Overview
--------

BASIC-1978 is an implementation of the BASIC language.

My references are Kemeny and Kurtz's "BASIC Programming" (John Wiley and Sons, 1967), James S. Coan's "Basic BASIC" (Hayden, 1978), David Ahl's "101 BASIC Computer Games" (DEC, 1973), and DEC's reference manual for BASIC PLUS.

The code for the interpreter is a fork of my BASIC-1973 project, with changes to bring the language closer to Microsoft's BASIC interpreters of the late 1970s.
BASIC-1978 includes features from BASIC-1965 (ARR and MAT statements) and BASIC-1973 (modifiers at the end of statements).
These features were not part of Microsoft BASIC, but were available in other BASIC interpreters.

Initial impressions
-------------------

BASIC-1978 is really primitive!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

BASIC-1978 is an interpreter.
BASIC-1965 caches the results of constant operations (such as 3 / 5).

The BASIC-1973 language has limited exception handling.
An exception handler can be specified with the ON ERROR statement.
The exception handler can correct the problem and continue execution with the RESUME statement.
 
Space characters are insignificant in most places.
When loading a program (or accepting new statements from the user), BASIC-1973 removes all spaces and then parses the line.

BASIC-1978 is really fussy!
~~~~~~~~~~~~~~~~~~~~~~~~~~~

BASIC-1978 keeps the spirit of the original BASIC language, as much as possible.
Everything must be in upper case, except for text literals in PRINT statements.
Commands ("RUN", "LIST"), statements ("PRINT", "LET"), function names, and variable names must be in upper case.
Lower case causes an error.

Cautions
~~~~~~~~

BASIC-1978 will not run every program that can run in BASIC-1973.
BASIC-1973 is an interpreter designed to run programs for a collection of interpreters from the early 1970s.
BASIC-1978 is designed to run programs for an early version of Microsoft BASIC.
(Something prior to Microsoft's BASIC-80.)

Absent from BASIC-1978 are:

       The INPUT$ statement
       The INPUT LINE statement
       The constant PI
       Hash constants (#J)
       ASCII character constants SOH, ETX, ACK, etc.
       The power operator ** (BASIC-1978 provides the caret ^ operator)
       The MIN and MAX operators
       The EXT$() function (BASIC-1978 provides the MID$() function)
       Comments that begin with '!' (BASIC-1978 allows for comments with the single quote)
       Three-letter abbreviations of statements
       The use of '&' as a synonym for PRINT


Running BASIC-1978
------------------

Interactive mode
~~~~~~~~~~~~~~~~

This is the classic mode, in which the user may edit programs and run them in the BASIC environment.
You may use any of the immediate commands (see below).

Interactive mode displays a prompt when it is ready for input.
The default prompt is 'READY'.
The prompt may be changed with the --prompt command-line option and the 'OPTION PROMPT' command.
Short prompts (length of one character) are displayed when BASIC is ready for input.
Long prompts (more than one character) are displayed when BASIC is ready for input but not after the entry of a program line.

Run mode
~~~~~~~~

This option runs BASIC-1978 and also loads a specified BASIC program and then either lists or runs it.
When the BASIC program ends, BASIC-1978 ends.

|==========
|Option |Effect
|--run filename |Specifies the file to load and run. May be abbreviated as -r
|--timing |Prints the CPU time usage at the end of the output.
|--profile |Display profile information after a program is run.
|--list filename |Specifies the file to load and list. May be abbreviated as -l
|--pretty filename |Specifies the file to load and pretty-print. May be abbreviated as -p
|--pretty-multiline |For pretty output, prints multistatement lines on multiplw lines, one statement per line.
|--parse filename |Specifies the file to load and parse.
|--analyze filename |Specifies the file to load and analyze.
|--trace |Print each statement prior to executing it (useful for debugging). Does the same thing as the 'OPTION TRACE TRUE' command in interactive mode, but from the command line.
|--asc-allow-all |The ASC(), ASC%(), ASCII(), and ASCII%() functions allow any characters. The default behavior is to limit characters to printable ASCII (32d to 126d).
|--back-tab |Allows the TAB() function to move to the left. Normally, it moves only to the right or not at all.
|--no-cache-const-expr |Disables caching of results of constant expressions.
|--chr-allow-all |The CHR$() function allows any output characters. The default behavior is to limit characters to printable ASCII (32d to 126d).
|--no-detect-infinite-loop |Disables checks for infinite loops.
|--echo-input |Echoes console input to output. Useful in run mode when redirecting input from a text file.
|--no-extend-if |Statements following an IF statement on the same line are not associated with the last clause of the IF statement.
|--field-sep-semi |Sets field separator for ARR PRINT and MAT PRINT statements to semicolon, which provides narrow spacing.
|--forget-fornext |Forgets the control value when a FOR/NEXT loop terminates, if it was undefined when the loop started.
|--heading |Suppress the heading and trailing messages
|--implied-semicolon |When printing items not delimited by a comma or semicolon, provide spacing as if a semicolon was provided. (Normally the items have no spaces between them.)
|--int-floor |The INT function truncates towards negative infinity. (Normally towards zero.)
|--lock-fornext |Lock control variables to FOR/NEXT loops. Variables can be read but not changed.
|--long-names |Allow long variable names. The default is variable names of one letter and one optional digit.
|--precision |Sets the precision for numeric variables. Default is 6, maximum is 16. Set to "INFINITE" for maximum precision provided by Ruby.
|--print-width width |Specifies a print width. Lines will wrap at the specified column. Default value is 72.
|--prompt PROMPT |Specifies the command prompt. Single-character prompts have no linefeed and occur more often.
|--promptd PROMPT |Specifies the debugger prompt. Single-character prompts have no linefeed and occur more often.
|--prompt-count |INPUT statement prompts the user with the number of expected values.
|--provenance |When displaying a variable in a trace, also display the line number where it was set.
|--qmark-after-prompt |On an INPUT statement, print the question mark after the prompt.
|--randomize |Forces new sequences of numbers from the RND() function on successive runs.
|--ignore-randomize |Forces the interpreter to ignore the RANDMIZE statements. Successive runs of the interpreter will use the same sequence of numbers from the RND() function. (Useful for testing.)
|--ignore-rnd-arg |The RND function ignores its argument and provides a number between zero and one. This matches the behavior of certain BASICs, including K&K.
|--require-initialized |Require that variables are initialized before they are used.
|--semicolon-zone-width |Enables print zones for semicolon carriage control.
|--tty |Print output slowly, emulating the speed of an ASR-33 Teletype. Provides a better experience with some programs (often games) in which slow output lets your anticipation build. The fast output of modern computers displays information quickly, and TTY mode lets you read each line as it is "printed".
|--tty-lf |Similar to --tty but delays only the newline characters, not each individual character. Useful with --trace when debugging.
|--wrap |Wraps subscripts out of range back into range.
|--zone-width width |Specifies a zone width. PRINT statements will position output separated by commas in zones. Default is 16.
|==========

Immediate commands
------------------

Immediate commands are executed on the command line.
They are not stored as part of the program.
They have no line number.
They are available only in interactive mode.

LOAD
~~~~

Loads a stored program into memory.
Sorts statements by line number.
Clears the current program prior to loading the new one.

Syntax:	LOAD filename

The 'filename' argument must be enclosed in quotes.

Clears all breakpoints.

SAVE
~~~~

Saves the current program to disk.
Will overwrite an existing file without prompting.

Syntax:	SAVE filename [OPTION] [BREAK]

The 'filename' argument must be enclosed in quotes.
The OPTION option includes OPTION settings in the file.
The BREAK option includes breakpoints and conditions in the file.

NEW
~~~

Clears the current program.
Does not ask to save a loaded program.

Syntax:	NEW

Clears all breakpoints.

LIST
~~~~

Lists the current program on the screen.

Syntax:	LIST [line specification]

The line specification may be in the form of a single line number, a range (two numbers separated by a hyphen), or a starting line and a count separated by a plus sign.

Examples:

|==========
|Command |Result
|LIST |Lists the entire program.
|LIST 100 |Lists line 100, if it exists. If the line does not exist, nothing is printed.
|LIST 100-199 |Lists all lines from line 100 to (and including) line 199.
|LIST 100+10 |Lists line 100 and the next 10 lines, regardless of their line nunbers.
|LIST 100+ |Lists line 100 and the next 20 lines.
|==========

RUN
~~~

Runs the current program.

Syntax:	RUN

Program execution occurs in two phases.
The first phase checks each statement for errors and executes some statements.
Any error detected at this stage will halt execution.
An error may be a syntax error or another error.
GOTO and GOSUB statements with undefined targets are examples of errors.

Statements executed in this first phase are the DATA, FILES, and DEF statements.
They are executed only once in a program, even if the path of execution travels to them multiple times.

The second phase executes statements, starting with the lowest-numbered statement and following the path of execution.

BREAK
~~~~~

Sets or displays breakpoints.

Syntax: BREAK line-number [IF condition]
Syntax: BREAK

To set a breakpoint, type 'BREAK' followed by a line number.
To display breakpoints, type 'BREAK' with no arguments.

Examples:

	BREAK 100
	BREAK 220 IF A <> 0
	BREAK 302 IF LEN(A$) > 0 AND ABS(T) < 100
	BREAK

Multiple conditional breakpoints may be set for the same line.

Breakpoints may be set for lines that do not exist.
The RUN command checks for breakpoints set for lines that do not exist and reports an error.

NOBREAK
~~~~~~~

Clears or displays breakpoints.

Syntax: NOBREAK line-number [IF condition]
Syntax: NOBREAK

To clear a breakpoint, type 'NOBREAK' followed by a line number.
To display breakpoints, type 'NOBREAK' with no arguments.

Examples:

	NOBREAK 100
	NOBREAK 220
	NOBREAK

Clearing the breakpoints for a line clears all breakpoints, absolute and conditional, for that line.

CROSSREF
~~~~~~~~

Lists the numeric literals, text literals, functions, and variables used in the program, along with the line numbers on which they appear.
For variables, assignments are listed on one line and references are listed on a second line.
The line with assignments shows the variable and an equals sign.

DELETE
~~~~~~

Removes lines from the program.

My experience with other BASIC interpreters is that lines can be deleted by simply typing a line number and pressing RETURN.
(That is, entering an "empty" line with line number and nothing else.)
That technique does not work with BASIC-1978, as BASIC-1978 allows empty lines to be part of a program.

So how to remove a line from a program?
Replacing a line with an empty line is possible, and certainly makes the offending line "go away" from execution, but what if we want to really remove a line?

That's what the DELETE command does.

DELETE uses the same specification as the LIST command.

Syntax:	DELETE [line specification]

If the list specification is a single line, it is deleted immediately.
If the list specification is a range, the lines are displayed and the user must confirm the operation.

The DELETE command with no specification (implying the entire program) does not delete the program but does nothing.
(To delete the entire program, use the NEW command.)

PRETTY
~~~~~~

Lists the current program on the screen, adjusting the spacing between keywords, variable names, and literals.

Syntax:	PRETTY [line specification]

The line specification is the same as the line specification for the LIST command.

PROFILE
~~~~~~~

Lists the current program on the screen in "pretty" mode, with additional information about the most recent run.
The profile information is enclosed in parentheses immediately after line numbers.
Each statement is printed on its own line.
Lines with multiple statements are split into individual statements.
Each line of the profile output starts with the statement line number and the index of the statement on the line.
For single-statement lines, the index is zero.
For multi-statement lines, each statement has a unique index starting with zero.

The line

    10 A=10 : B=20

will appear in the profile as

    10.0 (0.0005/1) A = 10
    10.1 (0.0005/1) B = 20


Syntax:	PROFILE [line specification]

The line specification is the same as the line specification for the LIST and PRETTY commands.

If option TIMING is TRUE, the profile information lists the total execution time for the statement and the number of times the statement was executed.
If option TIMING is FALSE, the profile information lists only the number of times the statement was executed.
The latter configuration is useful for regression tests.

Counts are reset at the start of each execution.

Profiling excludes the first phase of processing of certain lines (DATA, FILES, and DEF FN).
These lines are processed before the program begins, and they do nothing when executed in the main execution.
For example, placing a DATA statement inside of a FOR/NEXT loop does not cause the lines data values to be stored multiple times.

RENUMBER
~~~~~~~~

Renumbers lines in the current program.

Syntax: RENUMBER
Syntax: RENUMBER step
Syntax: RENUMBER step,start

Modifies the current program, changing each line number.
The first line is assigned the starting line number.
Each successive line is assgned a number a step higher than the previous line.

When no values are specified, the renumbering starts at 10 with steps of 10.
When one value is specificed, the renumbering starts at that value and steps at that value.
When two values are specified, the renumberind starts at the second value and steps at the first value.
When more than two values are specified, only two are used and the rest are ignored.

Each statement which contains a line number (GOTO, GOSUB, IF, ON/GOTO) is modified to use the corresponding new line number.

RENUMBER also adjusts breakpoints, if any are set.

DIMS
~~~~

Displays the dimensioned variables that have been defined in DIM statements.

VARS
~~~~

Displays the variables that have been assigned values.

UDFS
~~~~

Displays the defined user-defined functions.


TOKENS
~~~~~~

Similar to LIST, the TOKENS command displays a line or group of lines, showing the tokens identified by the tokenizer.

Syntax:	TOKENS [line specification]

The line specification is the same as the line specification for the LIST command.

PARSE
~~~~~

Similar to LIST and TOKENS, the PARSE command displays a line or group of lines, showing the tokens identified by the parser. 

Syntax:	PARSE [line specification]

The line specification is the same as the line specification for the LIST command.

ANALYZE
~~~~~~~

Analyzes the code.
Compiles metrics for complexity and lists lines which are not reachable.
Complexity metrics include lines of code, comment density, comprehension effort, McCabe complexity, and Halstead complexity.
Comprehension effort is my own measure of complexity, counting the number of operations in each statement.

OPTION
~~~~~~

Display or set various options for the BASIC interpreter.

Syntax: OPTION
Syntax: OPTION option
Syntax: OPTION option value

The first form ('OPTION' by itself) lists the options and their current values.
The second form lists a specific option and its current value.
The final form sets the value for an option.

These options can be initialized on the command line.
The OPTION command overrides the command-line setting.

|==========
|Option |Settable |Type |Default |Effect
|APOSTROPHE_COMMENT |N |TRUE or FALSE |Allow comments starting with single quote
|ASC_ALLOW_ALL |NLP |TRUE or FALSE |FALSE |The ASC(), ASC%(), ASCII(), and ASCII%() functions allow all characters
|BACK_TAB |NLP |TRUE or FALSE |FALSE |The TAB() function can move the printhead to the left
|BASE |NLP |numeric |0 |Sets the base for arrays and matrices to either 0 or 1
|CACHE_CONST_EXPR |NLP |TRUE or FALSE |TRUE |Cache result of operations on constant values and re-use instead of re-calculate
|CHR_ALLOW_ALL |NLP |TRUE or FALSE |FALSE |The CHR() function allows all characters
|DEFAULT_PROMPT |NLP |String |"? " |Changes the prompt for INPUT statements
|DETECT_INFINITE_LOOP |NLP |TRUE or FALSE |TRUE |Enables the detection of infinite loops
|ECHO |NLP |TRUE or FALSE |FALSE |Echoes input (useful for testing)
|FIELD_SEP |NLP |COMMA, SEMI, NL, or NONE |COMMA |Controls spacing of values in ARR PRINT and MAT PRINT statements
|HEADING |NLP |TRUE or FALSE |TRUE |Displays the opening and closing lines that identify BASIC
|IF_FOR_SUB |N |TRUE or FALSE |TRUE |Allows a FOR statement to be a substatement of an IF statement
|IGNORE_RND_ARG |NLP |TRUE or FALSE |FALSE |Ignores the argument to RND(), needed for some old BASIC programs
|IMPLIED_SEMICOLON |NLP |TRUE or FALSE |FALSE |Assume that a semicolon is specified between arguments to PRINT without intervening carriage control specified
|INPUT_HIGH_BIT |NLP |TRUE or FALSE |FALSE |INPUT$ statement sets high bit of character
|INT_BITWISE |N |TRUE or FALSE |TRUE |Operators AND, OR, and NOT perform bitwise operations on integer values
|INT_FLOOR |NLP |TRUE or FALSE |FALSE |Sets truncation towards negative infinity instead of towards zero
|LOCK_FORNEXT |NLP |TRUE or FALSE |FALSE |Do not allow changes to FOR/NEXT control variables within the loop
|NEWLINE_SPEED |NLP |numeric |0 |Limit printing speed only for newlines
|PRECISION |NLP |numeric 1 to 17, or "INFINITE" |9 |Sets the precision for numeric values
|PRETTY_MULTILINE |NL |TRUE or FALSE |FALSE |When pretty-listing, print each statement on its own line
|PRINT_SPEED |NLP |numeric |0 |Limit printing speed (a value of 10 emulates an old TeleType)
|PRINT_WIDTH |NLP |numeric |72 |Wrap output at the specified column; 0 disables wrapping
|PROMPT |NL |string |READY |Sets the text of the command prompt
|PROMPTD |NL |string |DEBUG |Sets the text of the debugger prompt
|PROMPT_COUNT |NLP |TRUE or FALSE |FALSE |Displays the number of items to be input
|PROVENANCE |NLP |TRUE or FALSE |FALSE |Expands trace display to include the line in which a variable was assigned its value
|QMARK_AFTER_PROMPT |NLP |TRUE or FALSE |FALSE |Display '?' after a prompt in an INPUT statement
|RANDOMIZE |NLP |TRUE or FALSE |FALSE |Randomize RND(); same as 'RANDOMIZE' statement 
|RELATIONAL_BOOLEAN |N |TRUE or FALSE |FALSE |Relational operators return boolean value (default is integer, like Microsoft BASIC-80)
|REQUIRE_INITIALIZED |NLP |TRUE or FALSE |FALSE |Variables must be initialized before use
|RESPECT_RANDOMIZE |NLP |TRUE or FALSE |TRUE |RANDOMIZE creates different values on each run
|SEMICOLON_ZONE_WIDTH |NLP |numeric |0 |Semicolon carriage control zone width (0 is no zone)
|SINGLE_QUOTE_STRING |NLP |TRUE or FALSE |FALSE |Allow strings delimited with single quotes ('STRING')
|TIMING |NLP |TRUE or FALSE |TRUE |After running a program, display time to execute (user time and system time)
|TRACE |NLP |TRUE or FALSE |FALSE |When running a program, display each line prior to execution
|WRAP |NLP |TRUE or FALSE |FALSE |When TRUE, subscripts beyond lower or upper bounds are wrapped
|ZONE_WIDTH |NLP |numeric |16 |Width of print zones for comma separators

Options can be changed when no program is loaded ('N'), when a program is loaded ('L'), or when a program is running ('P').
Options that affect the parsing or analyzing of programs can be changed only when no program is loaded.

When values to constant expressions are cached, setting the PRECISION or BASE options clear the cache of all values.
This is because calculations of constant values can be different after those options change.

Debug shell
-----------

The debug shell lets you pause execution, examine or change the program, and examine or change variables.
The shell is invoked by a breakpoint during a RUN.
Breakpoints are set by the BREAK command.

The debug shell is available only in interactive mode.
It is not available in programs run from the command line.

Commands in the debug shell are:

GO
~~

Continues execution of the program.

STOP
~~~~

Stops the debug shell and the program.

STEP
~~~~

Executes the current line and then re-invokes the debug shell.

BREAK
~~~~~

Display, set, or clear breakpoints.

LIST
~~~~

Lists program lines.

PRETTY
~~~~~~

Pretty-lists program lines.

DELETE
~~~~~~

Deletes program lines.
Actually replaces the lines with blank lines, to avoid confusing the interpreter by deleting the current line.

DIM
~~~

Assigns dimensions to a variable.

GOTO
~~~~

Assigns control to the specified statement.

LET
~~~

Assigns a value or values to a variable or variables.
The assigned value may be a literal or an expression.

PRINT
~~~~~

Prints one or more variables.

PROFILE
~~~~~~~

Prints profile information.
The TIMING option affects the format of the profile information.

Variables
---------

Variables store numeric, integer, and text values.
Numeric variables handle integer and floating point values automatically; integer variables are limited to integer values.

Variable names consist of a single letter and an optional digit and an optional subscript.
Subscripts are enclosed in parentheses.
Values for subscripts are truncated to integers.
The values 2.3 and 2.8 will both be converted to the value 2 when storing or retrieving values.

Names for text variables include a trailing '$' character.
Names for integer variables include a trailing '%' character.

|==========
|Name |Valid or reason it is not valid
|A |
|B |
|C |
|D1 |
|E0 |
|F |
|F1 |
|F2 |
|G(3) |
|H(17) |
|L(1,0) |
|A$ |
|B$ |
|D1$ |
|E0$ |
|F1$ |
|G$(3) |
|H$(17) |
|L$(1,0) |
|B[2] |
|I% |
|N2%(4%) |
|M%(5) |
|AA |Names may have at most one letter
|A10 |Names may have at most one digit after one letter
|9Z |Names must start with a letter
|A_2 |Names may not contain underscore
|K() |Subscripted names must have subscript values

With the --long-names option, variable names may be longer that the usual one alphabetic and one optional digit.
Long variable names may have any number of alphabetic characters followed by any number of digits.

When using long names, variables must be separated from statement keywords and function names.
With short names, variables do not need space characters to separate them.

|==========
|Name |Valid or reason it is not valid
|AAA |
|B123 |
|ACCOUNT123 |
|NAME12$ |
|INDEX% |
|F1R |Alphabetics must precede digits
|FIRST$NAME |Sigils for type ('$', '%') must be at the end


Variables do not need to be declared.
They are assumed to exist with value zero.

Expressions and operators
-------------------------

BASIC-1978 supports the following arithmetic operations for numeric expressions:

|==========
|Operation |Symbol |Precedence
|Posation (unary) |+ |1
|Negation (unary) |- |1
|Addition |+ |4
|Subtraction |- |4
|Multiplication |* |3
|Division |/ |3
|Exponent |^ |1
|==========

BASIC-1978 supports the following operations for string expressions:

|==========
|Operation |Symbol |Precedence
|Concatenation |+ |4
|Replication |* |3
|Inversion |NOT |1
|==========

BASIC-1978 supports the following operations for boolean expressions:

|==========
|Operation |Symbol |Precedence
|Inversion (unary) |NOT |1
|And |AND |2
|Or |OR |2
|==========

Operations are logical, except for operations on integer values (marked with '%').
Operations on integer values are bitwise when INT_BITWISE option is TRUE (the default).
Operations on integer values are logical when INT_BITWISE option is FALSE.

Parentheses may be used to force computations is a specific order.
The expression A+B*C performs the multiplication first; the expression (A+B)*C performs the addition first.

Errors in computation (overflow, underflow, and divide by zero) cause execution to stop, unless a handler has been specified with ON ERROR.

BASIC-1978 supports the following boolean comparisions for numeric variables:

|==========
|Operation |Symbol
|Equal |=
|Not equal |<>
|Greater than |>
|Greater than or equal |>=
|Less than |<
|Less than or equal |<=
|==========

BASIC-1978 supports the following boolean comparisions for string variables:

|==========
|Operation |Symbol
|Equal |=
|Not equal |<>
|Greater than |>
|Greater than or equal |>=
|Less than |<
|Less than or equal |<=
|==========

BASIC-1978 supports the following boolean operations

|==========
|Operation |Symbol
|Logical 'and' |AND
|Logical 'or' |OR
|==========

Boolean comparisons and operations are sensible only within IF statements.
They cannot be used in assignment statements as the target variable must be either numeric or string type.

Numeric values
--------------

Numeric values are either integers or floating point.
Integer values may contain a trailing '%' character.
Integers are stored internally with Ruby's Fixnum class.
Floating point numbers are stored as Ruby's Float with precision specified by the PRECISION option.

Numeric literals may be integer or real, and may use E-notation with unsigned exponents.
The 'E' must be uppercase; a lowercase 'e' will be rejected.
Exponents may be signed or unsigned.

|==========
|Numeric literal |Valid or reason not valid
|0 |
|1 |
|2 |
|-5 |
|17 |
|123456789 |
|1.03 |
|-2.17 |
|1E4 |
|-2E3 |
|1E-2 |
|2.37E+4 |
|2% |
|0A |Only digits 0 through 9 and decimal points (and the 'E' for exponent) are permitted.
|3.03+E3 |The sign for the exponent must be after the 'E'. (This expression will be parsed as the value 3.03 plus the contents of variable E3.)
|1e4 |The 'E' for exponent must be uppercase.
|==========

BASIC-1978 converts integer and numeric values readily.
Many original variants of BASIC required an exact type match (integer to integer, numeric to numeric).
BASIC-1978 does not require an exact match.
It will convert the original value to the expected type.
The conversion may result in a change of value, as integers cannot hold fractional values.

String values
-------------

String values are text.
Literals in the program are enclosed in double quotes.

|==========
|Text literal |Valid or reason not valid
|"A" |
|"Hello" |
|"Anytown, USA" |
|"A "quoted" string" |Text literals may not contain the double quote character
|'A "quoted" string' |Valid if --single-quote-strings is specified

BASIC-1978 converts numeric values (floating point or integer) to strings readily.

Strings at the end of the line do not need a terminating quote.

Program statements
------------------

Program statements are stored as part of the program.
Every program statement must have a line number.
Every statement begins with a keyword except for the LET-less assignment.

A line may contain a comment denoted by a single quote.
Everything to the right of the comment lead character is a comment.

Line numbers
~~~~~~~~~~~~

Line numbers are integers in the range from 1 to 32767.

Empty lines
~~~~~~~~~~~

A line number with no following text is an empty line.
It is retained as part of the program, but performs no action during execution.

Examples:

	10
	120
	6731

Multistatement lines
~~~~~~~~~~~~~~~~~~~~

Multiple statements may be placed on a single line, separated by colon characters.

Examples:

	20 PRINT "HELLO" : GOSUB 220 : PRINT "GOODBYE"
	300 FOR I = 1 TO 10 : A(I) = I * 2 : NEXT I

CHAIN
~~~~~

Transfers control to a second BASIC program.
Execution begins at the first line of the second program.

Syntax: CHAIN "filename"

The file name may contain a path.
Trailing whitespace characters are removed from the file name.

The CHAIN operation preserves variables, dimension specifications, and open files.
It destroys definitions for user-defined functions, the call stack for GOSUB statements, and the internal blocks for active FOR/NEXT statements.
(You cannot RETURN from the second program to the first program, but you can CHAIN back.)

CHANGE
~~~~~~

Changes string variables to an array of numbers, or an array of numbers to a string variable

Syntax:	CHANGE variable TO variable
Syntax:	CHA variable TO variable

The two variables must refer to a numeric array and a string variable (one of each).

When converting an array to a string the CHANGE statement is equivalent to an assignment with the PACK$() function.
When converting a string to an array, the statement is equivalent to an assignment with the UNPACK%() function.

Examples:

	90 CHANGE A TO A$
	100 CHANGE B$ TO C
	110 CHANGE A1 TO Z4$

The array of numeric values contains the length in the zero position and one value for each character in the corresponding string.

OPTION BASE 1 breaks the CHANGE command, because CHANGE relies on PACK$() and UNPACK%().

CLOSE
~~~~~

Closes a file.

Syntax: CLOSE #1

The CLOSE command should not be used with files opened with a FILES command.

DATA
~~~~

Specifies values for READ, ARR READ, and MAT READ statements

Syntax:	DATA value list

Values must be numeric separated by commas.
Expressions may be numeric or string, but must match the variable that will be used in the READ statement.
Text literals must be enclosed in quotes.

Examples:

	390 DATA 3, 150, 175, 180
	400 DATA 2
	410 DATA "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY"

The DATA statement is processed before the program runs, and processed only once.
Thus, it may appear at the end of the program, and does not have to appear before a READ statement.

But the side effect from processing the statement only once is ... the statement is processed only once (per run).
A DATA statement inside a FOR/NEXT loop is processed only once, not once for each loop execution.

The common behavior for all BASICs is to parse the values as literals.
BASIC-1978 parses the values as numeric expressions, due to its parsing of unary operators as separate from numeric values.
The value '-1' is parsed as a unary minus and the value 1, which must be evaluated as an expression.
This behavior of BASIC-1978 allows for any expression in DATA statements, including the use of variables and functions, but since DATA statements are interpreted before the program is run (and interpreted only once even if contained by a loop) variables will evaluate to zero.

You can use expressions with only numeric literals, such as 3/4 or SIN(0.25).

DEF
~~~

Specifies a user-defined function.
User-defined functions may be expression-based or statement-based.

Syntax:	DEF name(parameters) = expression
Syntax: DEF name(parameters)

User-defined functions have names in the form 'FNxn' where 'x' is a single letter and 'n' is an optional digit.

The parameters in the definition must be single letters.
They are not variable names.
The invokation of the function may provide a variable name or value as arguments.
(See examples below.)

The parameters specified in the definition are substituted into the expression at run-time; other variables specified in the expression are evaluated as usual, using the existing values at the time of execution.

The definition for an expression-based user-defined function is an expression, similar to the right-hand side of the assignment in a LET statement.

Examples:

	10 DEF FNA(A) = INT(A)
	20 DEF FNB(C) = COS(C)/SIN(C)
	30 DEF FNC(C) = COS(C)/SIN(A)
	100 LET P1 = 3.1415
	105 LET R4 = 20.1
	110 LET A1 = FNA(R4)
	120 LET B1 = FNB(30/P1)
	130 LET A = 30/3.1416
	131 LET A1 = FNC(45/P1)

The definition for a statement-based user-defined function is a set of lines ending with an FNEND statement.

Examples:

	10 DEF FNA(H)
	20 FNA = H - 7
	30 FNEND

	100 DEF FNB(Q) : R1 = RND(0)*Q : FNB = INT(R1) : FNEND

You can GOTO or GOSUB within a function.
You cannot GOTO or GOSUB into the body of a user-defined function, or out of the body of a user-defined function, or from one user-defined function to another user-defined function.

The DEF statement is processed before the program runs, and processed only once.
Thus, it does not have to appear before it is used in a LET statement.
(Although tradition is that the DEF is specified before the function is used.)

Multiple functions may be defined with the same name, provided they have different signatures.

Examples:

	10 DEF FNA(A) = INT(A)
	20 DEF FNA(C,B) = COS(C)/SIN(B)
	30 DEF FNA(A,B,C) = COS(C)/SIN(A)

DIM
~~~

Specifies the number of dimensions and maximum subscripts for each dimension.
(Without a DIM statement, variables may have a single dimension of at most 10.)

Examples:

	10 DIM A(20)
	20 DIM B(15), C(20,30)

When arrays are zero-based, the DIM A(20) statement allows for values A(0) through A(20).

OPTION BASE 1 changes arrays to one-based, but does not change the upper bound.
With OPTION BASE 1, the statement DIM A(20) allows for values A(1) through A(20).

END
~~~

Marks the end of the program.
An END statement, when executed, will force the execution of the program to stop.

Syntax:	END

Examples:

	999 END

The END statement must be the last statement in the program, and there should be only one of them.

FOR
~~~

Performs a sequence of statements for a specific number of times.

Syntax:	FOR control variable = starting value TO ending value
Syntax:	FOR control variable = starting value TO ending value STEP iteration value
Syntax:	FOR control variable = starting value STEP iteration value TO ending value
Syntax: FOR control variable = starting value UNTIL condition
Syntax: FOR control variable = starting value UNTIL condition STEP iteration value
Syntax: FOR control variable = starting value STEP iteration value UNTIL condition
Syntax: FOR control variable = starting value WHILE condition
Syntax: FOR control variable = starting value WHILE condition STEP iteration value
Syntax: FOR control variable = starting value STEP iteration value WHILE condition

The statements after the FOR statement (up to the accompanying NEXT statement) are repeated.
The control variable may not have subscripts.
The starting value, ending value, and iteration value may be integers or real.
If the starting value is greater than the ending value (or less than the ending value, when the STEP value is negative) then the statements between the FOR statement and the next NEXT statement with a matching control value are not executed.

A STEP value of zero will cause a loop that does not end.

The variable after termination of the loop is usually the end value specified in the FOR statement.
The value after termination may vary, depending on the initial value, the end value, and the step value.

Examples:

	10 FOR I = 1 TO 10
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 TO 10 STEP 2
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 STEP 0.5 TO 10.5
	20 PRINT I
	30 NEXT I

	10 FOR I = 10 TO 1 STEP -1
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 UNTIL I = 10
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 UNTIL I = 10 STEP 2
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 STEP 2 UNTIL I = 10
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 WHILE I < 10
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 WHILE I < 10 STEP 2
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 STEP 2 WHILE I < 10
	20 PRINT I
	30 NEXT I

It is possible to change the value of the control value within the loop. You can write:

	10 FOR I = 1 TO 10
	20 PRINT A
	30 LET I = 2
	40 NEXT I

This will lock the program into a permanent loop, as the value of I will never reach 10.

The LOCK_FORNEXT option prevents such changes.
When LOCK_FORNEXT is specified, an attempt to change a control variable causes an error.
The variable may be changed after the FOR/NEXT loop terminates.
Note that a GOTO to outside of the FOR/NEXT loop does not terminate the loop or unlock the variable.

Variables may be used to indicate the loop start, end, and step values.
The start, end, and step values are calculated at the beginning of the loop.
They are not re-calculated during the loop execution.
If variables are used, assignments to those variables in the loop will have no affect on the loop.

FORGET
~~~~~~

Removes a variable (or group of variables) from memory.

Syntax: FORGET variable [, variable...]

Examples:
	100 FORGET A
	120 FORGET B,C

The FORGET command is useful with the REQUIRE_INITIALIZED option.
It is a way to force a variable 'out of scope' or to be forgotten.
Forgotten variables are not initialized, and references to them will cause an error.

The FORGET_FORNEXT option causes the interpreter to forget the value of the control variable when the loop terminates.
This effectively limits the scope of the variable to the FOR/NEXT loop.
Useful when REQUIRE_INITIALIZED is TRUE; a later reference to the control variable will be an error.
BASIC forgets the variable only if it was not defined.
If the variable was defined prior to the FOR, the variable is left defined but modified by the FOR/NEXT loop.

GOTO
~~~~

Changes the flow of the program.

Syntax:	GO TO line number
Syntax:	GOTO line number
Syntax: GOTO expression OF line number, line number, line number, ...

Examples:

	300 GOTO 100
	310 GOTO 25
	330 GOTO A OF 100, 130, 180
	340 GOTO A*2+C OF 500, 550, 620, 750

The GOTO OF form is identical to the ON GOTO statement.
The expression is evaluated and the integral value is used as an index for the list of line numbers.
The selected line number is the next line number executed.

Notice that the command "350 GO TO 350" is legal but not sensible.
BASIC will detect an infinite loop and stop the program.

GOSUB
~~~~~

Changes the flow of the program by calling a subroutine.

Syntax:	GOSUB line number

Examples:

	300 GOSUB 400

Notice that the command "350 GOSUB 350" is legal but not sensible.
BASIC will detect an infinite loop and stop the program.

IF/THEN, IF/THEN/ELSE
~~~~~~~~~~~~~~~~~~~~~

Conditionally changes the flow of the program, based on an expression.

Syntax:	IF expression THEN line number
	IF expression THEN statement
	IF expression THEN line number ELSE line number
	IF expression THEN statement ELSE line number
	IF expression THEN line number ELSE statement
	IF expression THEN statement ELSE statement

The "target" after the THEN keyword must be a line number or a statement.
Statements after THEN or ELSE are restricted.
They cannot be DATA, DEF, END, or FNEND.
The IF_FOR_SUB option allows the FOR statement to be a substatement.

The expression may evaluate to a true or false value, or may evaluate to a numeric or text value.
Numeric values of zero are treated as false; other values are considered true.
String values of "" are treated as false; other values (including "false", "no", "F") are considered true.

Examples:

	100 IF A = 1 THEN 200
	110 IF A > B THEN 250
	120 IF G1 <= G2 THEN 301
	130 IF A$ = "HELLO" THEN 202
	150 IF A = 10 THEN PRINT "SUCCESS"
	200 IF B > 5 THEN 120 ELSE 300
	210 IF B > 5 THEN PRINT "B > 5" ELSE PRINT "B <= 5"
	300 IF C = 0 THEN IF D = 4 THEN PRINT "DONE"

When the expression evaluates as true, the THEN clause is executed.
When the clause is a line number, that line is executed next.
When the clause is a statement, that statement is executed.
Statements following an IF statement on the same line are associated with the THEN or ELSE statement of the IF statement, if the THEN or ELSE clauses are statements.

in the code:

     	100 IF A = 10 THEN PRINT "A=10":PRINT "ALL DONE"
	110 LET C = 20

When A is equal to 10, the text "A=10" is printed, and then the text "ALL DONE" is printed, and then C is set to 20.

When the expression evaluates as false, the THEN clause is not executed. Whether the clause is a line number or a statement, it is skipped and the next statement is executed.

In our example code, when A is not equal to 10, the text "ALL DONE" is not printed.
The statements which follow an IF statement on the same line are associated with the THEN or ELSE clause and executed with that statement.

The --no-extend-if option changes this behavior. When specified, the statements following the IF statement are distinct from the IF statement.

In our example code, when --no-extend-if is specified and A is equal to 10, "A=10" and "ALL DONE" are printed, and C is set to 20.
When A is not equal to 10, "ALL DONE" is printed and C is set to 20.

INPUT
~~~~~

Prompts the user and allows the user to enter one or more values.

Syntax:	INPUT [prompt,] variable list
Syntax:	INP [prompt,] variable list

Examples:

	60 INPUT U
	65 INPUT V1, V2, V3
	70 INPUT "Enter values: ", A, B
	80 INPUT A$

The default prompt is a single question mark (?) character.
This prompt can be changed to any text value by specifying a text value as the first parameter.
(This value must be a text literal. You cannot create a variable prompt such as INPUT P$, A$ because the variable for the prompt will be considered a normal variable for input.)
When multiple values are specified, they may be entered on one line with commas as separators.
If an insufficient number of values is entered, BASIC will prompt for more data.
These prompts are always the question mark, not the specified prompt.

When parsing input data, BASIC splits the input on commas. Each item is read as either a number or a text item.
If a value can be read as a number, it must be stored as a numeric variable.

Input values may be enclosed in quotes. These values will be treated as string variables, even when the contents are numeric.
Commas enclosed in quotes are part of the data, not used to split the data items.

Text values containing space characters must be enclosed in quotes. The quotes will not be part of the variable contents.

BASIC removes leading and trailing spaces from unquoted items.

INPUT statements are not affected by the --input-high-bit option.
(Only the INPUT$ statement is affected.)

Examples:

	40 INPUT A$
	50 INPUT B$,C$

Can read:
? GEORGE WASHINGTON
? "1600 PENN", WASHINGTON DC

Can read as the same:
?   GEORGE WASHINGTON
? "1600 PENN"   ,      WASHINGTON DC

Or:
? "GEORGE WASHINGTON"
? "1600 PENN", "WASHINGTON, DC"

Not the same (because of trailing spaces inside quotes):
? "  GEORGE WASHINGTON"
? "1600 PENN  ", "WASHINGTON, DC"

The LINE INPUT statement is similar to this statement, but reads an entire line at one time.

LET
~~~

Assigns a value or group of values to a variable or a group of variables.

Syntax:	LET target variable [, target variable...] = expression

Examples:

	40 LET A = 0
	50 LET B = A + 10
	55 LET C = C + 1
	60 LET C$ = "HELLO, WORLD!"
	70 LET D, E = A + B

Expressions may use a combination of operators, functions, and variables.

Variables may be swapped:

	80 LET A, B = B, A

If more values than targets are specified, the extra values are dropped.
If more targets than values are specified, the last value is repeated for the extra targets.

Targets must have the same type, as the same value is assigned to each target.

LET-less assignment
~~~~~~~~~~~~~~~~~~~

Assigns a value to a variable or a group of variables.

Syntax:	target variable [, target variable...] = expression

Examples:

	40 A = 0
	50 B = A + 10
	55 C = C + 1
	70 D, E = A + B

Expressions may use a combination of operators, functions, and variables.

Variables may be swapped:

	80 LET A, B = B, A

If more values than targets are specified, the extra values are dropped.
If more targets than values are specified, the last value is repeated for the extra targets.

Targets must have the same type, as the same value is assigned to each target.

LINE INPUT
~~~~~~~~~~

Prompts the user and allows the user to enter a text value.

Syntax:	LINE INPUT [prompt,] variable list
Syntax:	LINPUT [prompt,] variable list

Examples:

	60 LINE INPUT U$
	65 LINPUT V$
	70 LINPUT "Enter address: ", A$

The default prompt is a single question mark (?) character.
This prompt can be changed to any text value by specifying a text value as the first parameter.
(This value must be a text literal. You cannot create a variable prompt such as LINPUT P$, A$ because the variable for the prompt will be considered a normal variable for input.)

When parsing input data, reads all text on a line and stores it in the variable.
Quotes are not necessary.
BASIC keeps leading and trailing spaces.

Examples:

	40 LINPUT A$
	50 LINPUT B$

Can read:
? GEORGE WASHINGTON
? 1600 PENN, WASHINGTON DC

NEXT
~~~~

Denotes the end of a FOR loop.

Syntax:	NEXT variable, variable...
Syntax: NEXT

You can GOTO out of FOR/NEXT loops, and BASIC-1978 follows the examples set by Kemeny and Kurtz.

For example:

	10 REM Sample
	20 FOR I = 1 TO 10
	30 PRINT I
	40 IF I = 7 GOTO 60
	50 NEXT I
	60 STOP
	90 END

The above code will print the values 1 through 7 and then stop.

You can specify multiple variables.

    	10 FOR I = 1 TO 3
	20 FOR J = 1 TO 4
	30 PRINT I*J
	40 NEXT J, I
	99 END

When specifying multiple variables, specify the variable for the most recent FOR statement first.

You can omit variables, and let BASIC-1978 identify the proper control variable.

	10 REM Sample
	20 FOR I = 1 TO 10
	30 PRINT I
	40 IF I = 7 GOTO 60
	50 NEXT
	60 STOP
	90 END

You can omit variables from a list.

    	10 FOR I = 1 TO 3
	20 FOR J = 1 TO 4
	30 PRINT I*J
	40 NEXT , I
	99 END

You can even omit all of the variables in the list.

    	10 FOR I = 1 TO 3
	20 FOR J = 1 TO 4
	30 PRINT I*J
	40 NEXT ,
	99 END

Notice that the comma is needed to indicate that two loops are handled by the NEXT statement.

You can GOTO out of a loop and later GOTO back into it.
BASIC-1978 will remember the state of the loop.
If you GOTO into a FOR/NEXT loop (without activating it by the FOR statement), the eventual NEXT statement will cause an error.

ON ERROR GOTO
~~~~~~~~~~~~~

Specifies a line to transfer control in the event of an error.

Syntax: ON ERROR GOTO line number

Normally, when BASIC detects an error in a program, it stops the program.
After executing ON ERROR GOTO, BASIC will transfer control to the specified line when an error occurs.

Control is restored to the original statement that had the error when a RESUME statement is executed.

If an error occurs in the "error handler" specified by ON ERROR GOTO, the program stops, unless another ON ERROR GOTO statement is executed as part of the error handler.

Consult the file ErrorCodes.txt for a list of error codes and their meanings.
All of the errors in ErrorCodes.txt are trappable with ON ERROR GOTO.

ON GOTO/GOSUB
~~~~~~~~~~~~~

Changes the flow of the program to one of a number of possible destinations.

Syntax: ON expression GOTO line number, line number, line number...
Syntax: ON expression GOSUB line number, line number, line number...

The expression is evaluated and its result is used as an index into the list of line numbers.
The result is rounded to an integer prior to selecting the line number.
The value 1 selects the first line number.
A value of zero, a negative value, or a value greater than the length of the list causes an error.

Examples:

	90 ON A/B GOTO 100, 120, 140, 180
	190 ON C GOTO 250, 200
	220 ON INT(RND()*5)+1 GOSUB 450, 650, 320, 100, 144

Traditionally, target line numbers are listed in increasing order.
Line numbers may appear in any order.

OPEN
~~~~

Opens a file

Syntax: OPEN "FILE.TXT" FOR INPUT AS #1
Syntax: OPEN "OUTPUT.TXT" FOR OUTPUT AS #2
Syntax: OPEN "OUTPUT.TXT" FOR APPEND AS #3

Opens the file and prepares it for access.
When opening a file for output, it does not need to exist.
A file opened for output is erased before data is written.
When opening a file for append, new data is written at the end of the file.

The file name may be any file name suitable for your environment.
It may contain lower case letters.
The file name may contain device and directory names.

OPTION
~~~~~~

Sets an option for the interpreter.

Syntax: OPTION option expression

Possible options are a subset of the options in the shell.
Refer to the OPTION command for options that can be set in the program.

Expression must evaluate to a boolean value.
It may be 'TRUE' or 'FALSE' or a more complex expression.

Examples:

	10 OPTION TRACE TRUE
	40 OPTION PROVENANCE A > 0
	100 OPTION BASE 1

Unlike other interpreters, the OPTION statement is executed in-line.
It is not a setting prior to the execution of the program.

A program may contain multiple OPTION statements.
Each will be executed as a normal statement, in its sequence.

PRINT
~~~~~

Displays a set of variables and literals to the console, with a newline character.

Printing to console
^^^^^^^^^^^^^^^^^^^

Syntax:	PRINT expression list

Items in the list are separated by either commas or semicolons.
A comma forces the next item to the next tab stop (tab stops are every 14 positions).
A semicolon makes the next item adjacent to the previous item (or to the next semicolon zone, if semicolon zones are enabled).

Examples:

	10 PRINT
	20 PRINT A
	30 PRINT A, B
	40 PRINT "Output"
	50 PRINT "Results:", R1
	60 PRINT "Results:"; R2

The list may include terminating separators.
A terminating semicolon will suppress the newline.
A terminating comma will advance to the next tab position and suppress the newline.
.
	10 PRINT "Processing...";
	... other statements that generate no output
	20 PRINT "done"

results in the text "Processing...done" on the console.

The semicolon separator will force a small space between items.
Between strings, there is no space.
If semicolon zones are enabled (width greater than zero), then BASIC will advance to the next zone.

Printing to files
^^^^^^^^^^^^^^^^^

Syntax:	PRINT #filenum; expression list

Items in the list are separated by either commas or semicolons.
A comma or semicolon writes a SPACE character to the file.

Examples:

	10 PRINT #1
	20 PRINT #2, A
	30 PRINT #3; A, B
	40 PRINT #4; "Output"
	50 PRINT #5, "Results:", R1
	60 PRINT #6, "Results:"; R2

The list may include terminating separators.
A terminating comma or semicolon will write a SPACE and suppress the newline.

	10 PRINT #2; "Processing...";
	... other statements that generate no output
	20 PRINT #2; "done"

results in the text "Processing... done" to the file.

Numbers are printed with automatic formatting.
BASIC-1965 will print a number with the necessary number of decimal places.
It is not possible to force a number of decimal places.

PRINT USING
^^^^^^^^^^^

Displays a series of expressions to the console, formatting each item.

Syntax: PRINT USING formatstring, expression [,expression...]
Syntax: PRINT #filenum; USING formatstring, expression [,expression...]

The USING keyword may occur multiple times within the PRINT statement.

The format string may be a literal or variable or an expression.

There are four specifications for formatting in the format string: numeric, character, total string, and padded string.

The numeric format is indicated with '#' characters (one or more) and formats a numeric value as right-justified and padded with spaces.
A decimal point may be included, such as '###.##'.
The decimal point must be embedded in the string, and not the leading character.
The leading characters may be asterisks ('*') which will pad the field with asterisks and not spaces.
The leading character may be a dollar sign ('$') which will print a dollar sign before the padded value.
If a numeric value is too large to fit in the defined field, the entire numeric value is printed.

The character format is indicated with a '!' character (just one) and prints the first character of a string value.

The total string format is indicated with a '&' character (just one) and prints the entire string.

The padded string format is indicated with a pair of backslash characters ('\') enclosing zero or more space characters and prints the string left-justified and padded with space characters.

All other characters in the format string are treated as constant text which is printed as is.

Examples:

	240 PRINT USING "###", N
	250 PRINT USING "!", A$		' PRINT FIRST CHARACTER
	260 PRINT USING "NAME: &", A$	' PRINT ENTIRE STRING
	270 PRINT USING "TOKENS: \  \, \  \", T1$, T2$

	300 PRINT USING "NAME: &", N$; USING "AMOUNT: #######", A

Format strings may contain multiple specifications.
The number of specifications must match the number of values given after the format string.
Separators between values (commas and semicolons) do not have their usual effect of spacing values.
A comma or semicolon at the end of the list of values does have its usual effect on the carriage (space to next zone or suppress carriage return).

There may be additional values after the values printed by the PRINT USING clause.
These values are printed normally.

RANDOMIZE
~~~~~~~~~

Set a new seed for the random number generator.

Syntax:	RANDOMIZE

Example:

	4 RANDOMIZE


Without RANDOMIZE, successive runs of a program will use the same sequence of numbers from the RND() function.
The RANDOMIZE statement randomizes the sequence, and successive runs will have different numbers.

The -–ignore-randomize option disables RANDOMIZE statements (the interpreter allows then but ignores them).

READ
~~~~

Loads variables with values from DATA statements or files.

Reading from DATA statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Syntax:	READ variable list

Examples:

	400 READ N
	410 READ A, B, C
	420 READ A$, B, C$

The number of values in a READ statement do not have to match the number of values in DATA statements.
The values defined in DATA statements are stored in a single list of use by all READ statements.
You may READ in pairs and define ten values per DATA statement.
You may READ ten items from DATA statements that contain one value each.

READing more values than are specified by DATA statements, in total, will cause an error.

BASIC keeps an internal pointer to the next data item.
This pointer can be reset with the RESTORE statement.

Reading from files
^^^^^^^^^^^^^^^^^^

Syntax:	READ #filenum; variable list

Examples:

	400 READ #1; N
	410 READ #2; A, B, C
	420 READ #3; A$, B, C$

Files are text files.
Values in the file must be separated by space or separator (comma or semicolon) characters.
The number of values in a READ statement does not have to match the number of values on a line in the input file.
The READ statement will read additional lines and collect values to fill are specified variables.
Values remaining on the text line are saved until the next READ statement.

READing more values than are specified by the file, in total, will cause an error.

BASIC keeps an internal pointer to the next data item.

REMARK
~~~~~~

Allows for a comment in the program.

Syntax:	REM any text

Examples:

	10 REM
	20 REM Beginning of my first program
	30 REMARK *----*

RESTORE
~~~~~~~

Resets the internal pointer for the READ statement.
After a RESTORE statement, a READ statement will read the first data item.

Syntax:	RESTORE

Examples:

	210 RESTORE

RESUME
~~~~~~

Returns control after an error occurs (and is presumably handled).

Syntax: RESUME
Syntax: RESUME line number

When no line number is specified, control returns to the statement which experienced the error.
When a line number is specified, execution resumes on that line.

Example:

	10 ON ERROR GOTO 4000
	100 OPEN "FILE.TXT" FOR INPUT AS #1
	110 READ #1, A$, B, C
	120 CLOSE #1
	130 PRINT A$, B, C
	999 STOP
	4000 REM ERROR HANDLING ROUTINE
	4010 OPEN "FILE.TXT" FOR OUTPUT AS #3
	4020 WRITE #3, "JOHN DOE",45,27
	4030 CLOSE #3
	4040 RESUME
	9999 END


In the this example program, if the file exists and BASIC can open it, lines 10 through 999 are executed and lines 4000 through 4040 are not used.
If the file does not exist, BASIC transfers control from line 100 to line 4000.
Lines 4000 through 4030 create a file with data.
Line 4040 returns control to line 100, which is re-executed.

Note that an infinite loop can occur.
If BASIC cannot open the file, but the error is not that the file does not exist, then execution will alternate between line 100 and lines 4000-4040.
The error will transfer control to line 4000.
Lines 4000-4030 will create a file.
Line 4040 will return control to line 100.
Line 100 will incur the same error.
This could happen if an earlier line (not shown) opened a file on handle #1.


Example:

	10 ON ERROR GOTO 100
	20 LET B = 10 / 0
	30 PRINT "ANSWER IS"; B
	99 STOP
	100 PRINT "ERROR IN CODE"
	110 LET B = 0
	120 RESUME 30
	999 END

In this program, the division in line 20 causes an error.
Control is transferred to line 100.
The error is corrected on line 110.
The RESUME statement on line 120 restores execution on line 30, not line 20.


RETURN
~~~~~~

Changes the flow of the program by returning from a subroutine.

Syntax:	RETURN

Examples:

	450 RETURN

A RETURN statement makes sense only after the execution of a matching GOSUB statement. A RETURN without a GOSUB will cause an error.

SLEEP
~~~~~

Pauses the execution of the program.

Syntax: SLEEP time
Syntax: SLE time

Examples:

	270 SLEEP 1 : REM SLEEP FOR ONE SECOND
	354 SLEEP S : REM PAUSE FOR THE COMPUTED TIME (IN SECONDS)


STOP
~~~~

Stops the execution of the program.

Syntax:	STOP

Examples:

	900 STOP

WRITE
~~~~~

Displays a set of variables and literals to the console, with a newline character. The same as the PRINT command, except that WRITE also provides delimiters between values.

Writing to console
^^^^^^^^^^^^^^^^^^

Syntax:	WRITE expression list

Items in the list are separated by either commas or semicolons.

Examples:

	10 WRITE
	20 WRITE A
	30 WRITE A, B
	40 WRITE "Output"
	50 WRITE "Results:", R1
	60 WRITE "Results:"; R2

The list may include terminating separators.
A terminating semicolon will suppress the newline.
A terminating comma will advance to the next tab position and suppress the newline.

	10 WRITE "Processing...";
	... other statements that generate no output
	20 WRITE "done"

results in the text "Processing...", "done" on the console.

Numbers are printed with automatic formatting.
BASIC-1965 will print a number with the necessary number of decimal places.
It is not possible to force a number of decimal places.

Writing to files
^^^^^^^^^^^^^^^^

Syntax:	WRITE #filenum; expression list

Items in the list are separated by either commas or semicolons.
A comma or semicolon writes a SPACE character to the file.

Examples:

	10 WRITE #1
	20 WRITE #2, A
	30 WRITE #3, A, B
	40 WRITE #4; "Output"
	50 WRITE #5, "Results:", R1
	60 WRITE #6; "Results:"; R2

The list may include terminating separators.
A terminating comma or semicolon will write a SPACE and suppress the newline.

	10 WRITE #2; "Processing...";
	... other statements that generate no output
	20 WRITE #2; "done"

results in the text "Processing..."; "done" to the file.

Numbers are printed with automatic formatting.
BASIC-1965 will print a number with the necessary number of decimal places.
It is not possible to force a number of decimal places.

ARR statements
--------------

The ARR statements operate on one-dimensional arrays.
Operations begin with the index specified in OPTION BASE.

ARR FORGET
~~~~~~~~~~

Removes an array variable (or group of array variables) from memory.

Syntax: ARR FORGET variable [, variable...]

Examples:
        100 DIM A(10), B(20), C(33)
	110 REM lots of code here
	400 ARR FORGET A
	420 ARR FORGET B,C

The FORGET command is useful with the REQUIRE_INITIALIZED option.
It is a way to force a variable 'out of scope' or to be forgotten.
Forgotten variables are not initialized, and references to them will cause an error.

The ARR FORGET statement leaves the dimensions for the variable unchanged.

ARR INPUT
~~~~~~~~~

Loads array variables with values from the user or from files.

Inputting from the console
~~~~~~~~~~~~~~~~~~~~~~~~~~

Prompts the user and allows the user to enter a numeric value.
Non-numeric values are invalid and cause execution to stop.

Syntax:	ARR INPUT [prompt,] variable list

Examples:

	60 ARR INPUT U
	65 ARR INPUT V1, V2, V3
	70 ARR INPUT "Enter values: ", A, B

The default prompt is a single question mark (?) character.
This prompt can be changed to any text value by specifying a text value as the first parameter.
(This value must be a text literal.)
When multiple values are specified, they may be entered on one line with commas as separators.
If an insufficient number of values is entered, BASIC will prompt for more data.
These prompts are always the question mark, not the specified prompt.

Inputting from files
~~~~~~~~~~~~~~~~~~~~

Syntax: ARR INPUT #filenum; [prompt,] variable list

Examples:

	60 ARR INPUT #1; U
	65 ARR INPUT #3; V1, V2, V3
	70 ARR INPUT #2; "Enter values: ", A, B

An INPUT statement reads all values from a line of the input file.
Extra values are discarded.
If the line contains an insufficient number of values to fill all variables, BASIC reports an error.

ARR PRINT
~~~~~~~~~

Printing to console
^^^^^^^^^^^^^^^^^^^

Prints an array of values.

Syntax:	ARR PRINT variable list

Examples:

	100 ARR PRINT A
	110 ARR PRINT B;
	120 ARR PRINT A; B;
	130 ARR PRINT C, D

The values must be defined with DIM statements prior to printing.
Values are printed sequentially with as many values as will fit on a line.
The FIELD_SEP option specifies the spacing between values.
The FIELD_SEP SEMI option results in narrow columns, the FIELD_SEP COMMA option (the default) results in wide columns.

ARR PRINT statements may contain USING clauses.
For ARR PRINT, the USING clause may contain at most one field specification.
It may contain extra constant specifications.

Printing to files
^^^^^^^^^^^^^^^^^
 
Syntax:	ARR PRINT #filenum; variable list

Examples:

	100 ARR PRINT #1; A
	110 ARR PRINT #2, B;
	120 ARR PRINT #3; A; B;
	130 ARR PRINT #4; C, D

The values must be defined with DIM statements prior to printing.
Values are printed sequentially with each set of values on one line.

ARR READ
~~~~~~~~

Reads data into an array of values.

Reading from DATA statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Syntax:	ARR READ variable list

Examples:

	100 ARR READ A
	110 ARR READ B, C
	120 ARR READ D(15)

Dimensions may be supplied or omitted in ARR READ statements.
When supplied, they override any previous DIM or ARR READ or MAT READ statement.
When omitted, the variable must have dimensions specified in earlier DIM or ARR READ or MAT READ statements.

The values for dimensions may be numeric literals or expressions.
The expression is evaluated at run-time, like any other expression.

Data is read from DATA statements, as with the READ statement.

Reading from files
^^^^^^^^^^^^^^^^^^

Syntax:	ARR READ #filenum; variable list

Examples:

	400 ARR READ #1; N
	410 ARR READ #2; A, B, C
	420 ARR READ #3; A$, B, C$

Files are text files.
Values in the file must be separated by space or separator (comma or semicolon) characters.
The number of values in a READ statement does not have to match the number of values on a line in the input file.
The READ statement will read additional lines and collect values to fill are specified variables.
Values remaining on the text line are saved until the next READ statement.

READing more values than are specified by the file, in total, will cause an error.

BASIC keeps an internal pointer to the next data item.

ARR WRITE
~~~~~~~~~

Writes an array of values with separators.

Writing to console
^^^^^^^^^^^^^^^^^^

Syntax:	ARR WRITE variable list

Examples:

	100 ARR WRITE A
	110 ARR WRITE B;
	120 ARR WRITE A; B;
	130 ARR WRITE C, D

The values must be defined with DIM statements prior to printing.
Values are printed sequentially with as many values as will fit on a line.

Writing to files
^^^^^^^^^^^^^^^^
 
Syntax:	ARR WRITE #filenum; variable list

Examples:

	100 ARR WRITE #1; A
	110 ARR WRITE #2, B;
	120 ARR WRITE #3; A; B;
	130 ARR WRITE #4; C, D

The values must be defined with DIM statements prior to printing.
Values are printed sequentially with each set of values on one line.

ARR LET
~~~~~~~

Assigns a value or group of values to an array variable or group of array variables.

Syntax:	ARR LET target variable [, target variable...] = expression
Syntax:	ARR target variable [, target variable...] = expression

Examples:

	100 ARR LET A = B
	110 ARR LET A = B * C
	120 ARR A = B + D
	130 ARR A = B - E
	140 ARR A = 2 * B
	150 ARR A = 2 * B – E
	160 ARR G,H = A + B

Variables are assumed to represent array values.
If you want to use a scalar variable, enclose it in parentheses:

	130 LET S = 2
	140 ARR A = (S) * B
	150 ARR A = (S) * B - E

The expression is limited to arithmetic operations (addition, subtraction, multiplication, division, and exponentiation).
Certain operations are available for certain combinations of operands:

|==========
|First operand |Operation |Second operand |Restrictions |Actions
|Array |Addition |Array |Arrays must have identical dimensions |Corresponding elements are added
|Array |Subtraction |Array |Arrays must have identical dimensions |Elements from second array are subtracted from corresponding element in first array
|Array |Multiplication |Array |Arrays must have identical dimensions |Corresponding elements are multiplied
|Array |Division |Array |Arrays must have identical dimensions |Elements from the first array are numerators, elements from the second array are denominators
|Array |Power |Array |Arrays must have identical dimensions |Elements from the first array are raised to the corresponding element in the second array
|Scalar |Addition |Array ||Elements from the array are added to the scalar value
|Scalar |Subtraction |Array ||Elements from the array are subtracted from the scalar value
|Scalar |Multiplication |Array ||Elements from the array are multiplied by the scalar value
|Scalar |Division |Array ||Elements from the array are divided into the scalar value
|Scalar |Power |Array ||Elements from the array are the exponent of the scalar value
|Array |Addition |Scalar ||Elements from the array are added to the scalar value
|Array |Subtraction |Scalar ||The scalar value is subtracted from elements in the  array
|Array |Multiplication |Scalar ||Elements from the array are multiplied by the scalar value
|Array |Division |Scalar ||Elements from the array are divided by the scalar value
|Array |Power |Scalar ||Elements from the array are raised to the scalar value
|==========

Text operations are available for certain combinations of operands:

|==========
|First operand |Operation |Second operand |Restrictions |Actions
|Array |Concatenation |Array |Arrays must have identical dimensions |Corresponding elements are concatenated
|Scalar |Concatenation |Array ||Elements from the array are concatenated to the scalar value
|Array |Concatenation |Scalar ||The scalar value is concatenated to each element
|==========

Ahl makes no mention of the 'ARR' statement or any derived statements ('ARR PRINT', 'ARR READ').
I think that it makes sense to include them.

MAT statements
--------------

The MAT statements operate on matricies, which are either one- or two-dimensional arrays.
Operations begin with the index specified in OPTION BASE.

MAT FORGET
~~~~~~~~~~

Removes a maxtrix variable (or group of matrix variables) from memory.

Syntax: MAT FORGET variable [, variable...]

Examples:
	100 DIM A(3,4), B(10,4), C(100,22)
	110 REM lots of code here
	400 MAT FORGET A
	420 MAT FORGET B,C

The FORGET command is useful with the REQUIRE_INITIALIZED option.
It is a way to force a variable 'out of scope' or to be forgotten.
Forgotten variables are not initialized, and references to them will cause an error.

The MAT FORGET statement leaves the dimensions for the variable unchanged.

MAT INPUT
~~~~~~~~~

Loads matrix variables with values from the user or from files.

Inputting from the console
~~~~~~~~~~~~~~~~~~~~~~~~~~

Prompts the user and allows the user to enter a numeric value.
Non-numeric values are invalid and cause execution to stop.

Syntax:	MAT INPUT [prompt,] variable list

Examples:

	60 MAT INPUT U
	65 MAT INPUT V1, V2, V3
	70 MAT INPUT "Enter values: ", A, B

The default prompt is a single question mark (?) character.
This prompt can be changed to any text value by specifying a text value as the first parameter.
(This value must be a text literal.)
When multiple values are specified, they may be entered on one line with commas as separators.
If an insufficient number of values is entered, BASIC will prompt for more data.
These prompts are always the question mark, not the specified prompt.

Inputting from files
~~~~~~~~~~~~~~~~~~~~

Syntax: MAT INPUT #filenum; [prompt,] variable list

Examples:

	60 MAT INPUT #1; U
	65 MAT INPUT #3; V1, V2, V3
	70 MAT INPUT #2; "Enter values: ", A, B

An INPUT statement reads all values from a line of the input file.
Extra values are discarded.
If the line contains an insufficient number of values to fill all variables, BASIC reports an error.

MAT PRINT
~~~~~~~~~

Printing to console
^^^^^^^^^^^^^^^^^^^

Prints an array or matrix of values.

Syntax:	MAT PRINT variable list

Examples:

	100 MAT PRINT A
	110 MAT PRINT B;
	120 MAT PRINT A; B;
	130 MAT PRINT C, D

The values must be defined with DIM statements prior to printing.

For one-dimensional arrays, the values are printed sequentially with as many values as will fit on a line.

For two-dimensional matrices, values for each row in the matrix are printed on a line and a new line is used for each row.
The FIELD_SEP option specifies the spacing between values.
The FIELD_SEP SEMI option results in narrow columns, the FIELD_SEP COMMA option (the default) results in wide columns.

A newline is printed at the end of each line, so the carriage control characters of ',' and ';' have different meanings.
A comma adds an additional blank line after the matrix is printed.
A semicolon adds no blank line; it does nothing.

MAT PRINT statements may contain USING clauses.
For MAT PRINT, the USING clause may contain at most one field specification.
It may contain extra constant specifications.

Printing to a file
^^^^^^^^^^^^^^^^^^

Syntax:	MAT PRINT #filenum; variable list

Examples:

	100 MAT PRINT #1; A
	110 MAT PRINT #2, B;
	120 MAT PRINT #3; A; B;
	130 MAT PRINT #4; C, D

The values must be defined with DIM statements prior to printing.

For one-dimensional arrays, the values are printed on one line.

For two-dimensional matrices, values for each row in the matrix are printed on a line and a new line is used for each row.

A newline is printed at the end of each line, so the carriage control characters of ',' and ';' have different meanings.
A comma adds an additional blank line after the matrix is printed.
A semicolon adds no blank line; it does nothing.

MAT READ
~~~~~~~~

Reads data into an array or matrix of values.

Reading from DATA statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Syntax:	MAT READ variable list

Examples:

	100 MAT READ A
	110 MAT READ B, C
	120 MAT READ D(15)
	130 MAT READ E(6,11)

Dimensions may be supplied or omitted in MAT READ statements.
When supplied, they override any previous DIM or ARR READ or MAT READ statement.
When omitted, the variable must have dimensions specified in earlier DIM or ARR READ or MAT READ statements.

The values for dimensions may be numeric literals ot expressions.
The expression is evaluated at run-time, like any other expression.

Data is read from DATA statements, as with the READ statement.

Reading from files
^^^^^^^^^^^^^^^^^^

Syntax:	MAT READ #filenum; variable list

Examples:

	400 MAT READ #1; N
	410 MAT READ #2; A, B, C
	420 MAT READ #3; A$, B, C$

Files are text files.
Values in the file must be separated by space or separator (comma or semicolon) characters.
The number of values in a READ statement does not have to match the number of values on a line in the input file.
The READ statement will read additional lines and collect values to fill are specified variables.
Values remaining on the text line are saved until the next READ statement.

READing more values than are specified by the file, in total, will cause an error.

BASIC keeps an internal pointer to the next data item.

MAT WRITE
~~~~~~~~~

Writes an array or matrix of values.

Writing to console
^^^^^^^^^^^^^^^^^^

Syntax:	MAT WRITE variable list

Examples:

	100 MAT WRITE A
	110 MAT WRITE B;
	120 MAT WRITE A; B;
	130 MAT WRITE C, D

The values must be defined with DIM statements prior to printing.

For one-dimensional arrays, the values are printed sequentially with as many values as will fit on a line.

For two-dimensional matrices, values for each row in the matrix are printed on a line and a new line is used for each row.

Writing to a file
^^^^^^^^^^^^^^^^^

Syntax:	MAT WRITE #filenum; variable list

Examples:

	100 MAT WRITE #1; A
	110 MAT WRITE #2, B;
	120 MAT WRITE #3; A; B;
	130 MAT WRITE #4; C, D

The values must be defined with DIM statements prior to printing.

For one-dimensional arrays, the values are printed on one line.

For two-dimensional matrices, values for each row in the matrix are printed on a line and a new line is used for each row.

MAT LET
~~~~~~~

Assigns a value or group of values to a matrix variable or group of matrix variables.

Syntax:	MAT LET target variable [, target variable...] = expression
Syntax:	MAT target variable [, target variable...] = expression

Examples:

	100 MAT LET A = B
	110 MAT LET A = B * C
	120 MAT A = B + D
	130 MAT A = B - E
	140 MAT A = 2 * B
	150 MAT A = 2 * B – E
	160 MAT G,H = A + B

Variables are assumed to represent matrix values.
They may refer to variables dimensioned with one or two variables.

If you want to use a scalar variable, enclose it in parentheses:

	130 LET S = 2
	140 MAT A = (S) * B
	150 MAT A = (S) * B - E

The expression is limited to arithmetic operations (addition, subtraction, multiplication, division, and exponentiation).
Certain operations are available for certain combinations of operands:

|==========
|First operand |Operation |Second operand |Restrictions |Actions
|Matrix |Addition |Matrix |Matrices must have identical dimensions |Corresponding elements are added
|Matrix |Subtraction |Matrix |Matrices must have identical dimensions |Elements from second matrix are subtracted from corresponding element in first matrix
|Matrix |Multiplication |Matrix |Number of columns in second matrix must equal number of rows in first matrix |Computes dot product, which contains the number of columns of the first matrix and the number of rows in the second matrix
|Matrix |Division |Matrix |Not allowed |
|Matrix |Power |Matrix |Not allowed |
|Scalar |Addition |Matrix ||Elements from the matrix are added to the scalar value
|Scalar |Subtraction |Matrix ||Elements from the matrix are subtracted from the scalar value
|Scalar |Multiplication |Matrix ||Elements from the matrix are multiplied by the scalar value
|Scalar |Division |Matrix ||Elements from the matrix are divided into the scalar value
|Scalar |Power |Matrix ||Elements from the matrix are the exponent of the scalar value
|Matrix |Addition |Scalar ||Elements from the matrix are added to the scalar value
|Matrix |Subtraction |Scalar ||The scalar value is subtracted from elements in the matrix
|Matrix |Multiplication |Scalar ||Elements from the matrix are multiplied by the scalar value
|Matrix |Division |Scalar ||Elements from the matrix are divided by the scalar value
|Matrix |Power |Scalar | |Elements from the matrix are raised to the scalar value
|==========

Text operations are available for certain combinations of operands:

|==========
|First operand |Operation |Second operand |Restrictions |Actions
|Matrix |Concatenation |Matrix |Matrices must have identical dimensions |Corresponding elements are concatenated
|Scalar |Concatenation |Matrix ||Elements from the matrix are concatenated to the scalar value
|Matrix |Concatenation |Scalar ||The scalar is concatenated to each element
|==========

K&K BASIC restricts the assignment of a variable used in a matrix multiplication operation.
BASIC-1978 does not impose this restriction. You may write:

	110 MAT A = A * C

Functions
---------

Functions may be used in expressions.
|==========
|Function |Return type |Result
|ABS(x) |numeric |Computes the absolute value of x.
|ASCII(t$) |numeric |Returns the ASCII value of the first character of the string t. The character must be in the printable range of 32 to 126.
|ASCII%(t$) |integer |Returns the ASCII value of the first character of the string t. The character must be in the printable range of 32 to 126.
|ASC(t$) |numeric |Synonym for ASCII()
|ASC%(t$) |integer |Synonym for ASCII%()
|ARCCOS(x) |numeric |Computes the arccosine of x, providing the answer in radians.
|ARCSIN(x) |numeric |Computes the arcsine of x, providing the answer in radians.
|ARCTAN(x) |numeric |Computes the arctangent of x, providing the answer in radians.
|ARCTAN(y,x) |numeric |Computes the arctangent of y and x, providing the answer in radians.
|ATN(x) |numeric |Synonym for ARCTAN(x)
|ATN(y,x) |numeric |Synonym for ARCTAN(y,x)
|AVG(a) |numeric |Computes average of elements in array.
|CHR$(n) |string |Returns a string of one character, defined by n. N must be within the ASCII printable range of 32 to 126.
|CON1(n) |numeric array |Creates an array containing all ones, with n values
|CON2(n) |numeric matrix |Creates a matrix containing all ones, with n columns
|CON(n) |numeric matrix |Synonym for CON2(n)
|CON2(r,c) |numeric matrix |Creates a matrix containing all ones, with r rows and c columns.
|CON(r,c) |numeric matrix |Synonym for CON2(r,c)
|CON or CON() |numeric matrix |Creates a matrix containing all ones, with dimensions based on the assignment target.
|COS(x) |numeric |Computes the cosine of x, where x is in radians.
|COT(x) |numeric |Computes the cotangent of x, where x is in radians.
|CSC(x) |numeric |Computes the cosecant of x, where x is in radians.
|DET(m)	|numeric |Computes the determinant of the matrix. The matrix must be square.
|ERL(n) |numeric |Returns the line number (0), statement index (1), or modifier index (2) of the line which caused the current error.
|ERL() |numeric |Same as ERL(0)
|ERL |numeric |Same as ERL(0)
|ERR() |numeric |Returns the current error code.
|ERR |numeric |Same as ERR()
|EXP(x) |numeric |Computes e to the x power.
|FIX(x) |numeric |Returns the integer part of a number. Truncates towards negative infinity.
|FIX%(x) |integer |Returns the integer part of a number. Truncates towards negative infinity.
|FRAC(x) |numeric |Return the fraction part of a numeric value. Retains the sign of the original value.
|IDN(n) |numeric matrix |Creates an identity matrix (all zeros except for ones on the diagonal) fo dimension n.
|IDN(n,n) |numeric matrix |Same as IDN(x). The two values must be identical, as identity matrices are always square.
|IDN or IDN() |numeric matrix |Creates an identity matrix with dimensions based on the assignment target.
|INSTR(t$,s$) |numeric |Find string s in string t and report position.
|INSTR(i,t$,s$) |numeric |Find string s in string t and report position. Start search as position i (first position is 1, not 0).
|INSTR%(t$,s$) |integer |Find string s in string t and report position.
|INSTR%(i,t$,s$) |integer |Find string s in string t and report position. Start search as position i (first position is 1, not 0).
|INT(x) |numeric |Return the integer part of a numeric value. Truncates towards zero.
|INT%(x) |integer |Return the integer part of a numeric value. Truncates towards zero.
|LEFT$(t$,n) |string |Leftmost n characters of string t.
|LEN(t) |numeric |Returns the length of the string value.
|LOG(x) |numeric |Computes the natural log of x. A value of zero or a negative value will cause an error.
|LOG10(x) |numeric |Computes the base-10 log of x. A value of zero or a negative value will cause an error.
|LOG2(x) |numeric |Computes the base-2 log of x. A value of zero or a negative value will cause an error.
|MID$(t$,p,l) |string |Extract substring of t from position p for length l. The first character is position 1. If p is greater than the length of the string, the result is empty (""). If l extends beyond the end of the string, the result is ths string from p to the end.
|NCOL(m) |numeric |Number of columns in matrix m.
|NCOL%(m) |integer |Number of columns in matrix m.
|NELEM(a) |numeric |Number of elements in array a. Array may be of any type.
|NELEM%(a) |integer |Number of elements in array a. Array may be of any type.
|NROW(m) |numeric |Number of rows in matrix m.
|NROW%(m) |numeric |Number of rows in matrix m.
|NUM(x) |numeric |Converts string, integer, or boolean to numeric.
|PACK$(a) |string |Converts a numeric array to a string variable. The first element (index 0) must contain the number of numeric values to convert. (It may be zero.) Each numeric element is converted to the corresponding ASCII character.
|PROD(a) |numeric |Computes product of elements in array.
|PROD%(a%) |integer |Computes product of elements in array.
|RIGHT$(t$,n) |string |Rightmost n characters of string t.
|RND(x) |numeric |Return a random number from zero to x. The value is a floating-point value; RND(1) can return any value from zero to 1. A value of zero or less than zero is considered to be 1.
|RND() |numeric |Equivalent to RND(1).
|RND | numeric |Special form of RND, equivalent to RND(1).
|ROUND(x,p) |Rounds the value x to p places.
|SEC(x) |numeric |Computes the secant of x, where x is in radians.
|SGN(x) |numeric |Returns 1, 0, or -1, for positive, zero, or negative values of x.
|SIN(x) |numeric |Computes the sine of x, where x is in radians.
|SPACE$(n) |string |Creates a string of n space characters.
|SPC$(n) |string |Synonym for SPACE$()
|SPC(n) |string |Synonym for SPACE$()
|SQR(x) |numeric |Computes the square root of x. A negative value will cause an error.
|SUM(a) |numeric |Computes sum of elements in array.
|SUM%(a%) |integer |Computes sum of elements in array.
|STR$(n) |string |Converts numeric value to string.
|STR$(n,p) |string |Converts numeric value to string, formats with p decimal places.
|STRING$(t,n) |string |Repeats first character of string n times.
|TAB(n) |string |Advances the print position to column 'n'. Returns a string value with the proper number of spaces or backspaces. Useful in PRINT statements. In other statements, it returns the string value but does not advance the print position.
|TAN(x) |numeric |Computes the tangent of x, where x is in radians.
|TIME(n) |numeric |Returns the time since the start of the program, in seconds.
|TRN(m) |matrix |Transposes values in matrix m, exchanging values by rows and columns.
|UNPACK(t$)|numeric array |Converts a string variable (or expression) to an array of numeric values. The first element (index 0) contains the number of converted elements. Each element is the ASCII value for the corresponding character in the original string.
|UNPACK%(t$)|integer array |Converts a string variable (or expression) to an array of integer values. The first element (index 0) contains the number of converted elements. Each element is the ASCII value for the corresponding character in the original string.
|VAL(t$) |string |Converts a string to a numeric value. Ignores leading spaces. Converts digits and stops on first non-numeric character.
|ZER1(n) |numeric array |Creates an array containing all zeros, with n values
|ZER2(n) |numeric matrix|Creates a matrix containing all zeros, with n columns
|ZER(n) |numeric matrix|Synonym for ZER2(n)
|ZER2(r,c) |numeric matrix|Creates a matrix containing all zeros, with r rows and c columns.
|ZER(r,c) |numeric matrix|Synonym for ZER2(r,c)
|ZER or ZER() |numeric matrix |Creates a matrix containins all zeros, with dimensions based on the assignment target.
|==========

OPTION BASE 1 breaks the PACK$() and UNPACK%() functions, as they both access index position zero.


Array and matrix function special forms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The functions CON(), CON1(), CON2(), ZER(), ZER1(), ZER2(), and IDN() have normal forms and special forms.
You can use the normal form in simple assignments without specifying dimensions of targets:

	200 REM NO DIM STATEMENT FOR A OR B
	240 MAT A = CON(3,4)
	250 MAT B = IDN(4,4)
	260 ARR C = ZER1(7)

The special form allows for parameters to be omitted.

	200 REM DIM STATEMENTS FOR A AND B ARE NECESSARY
	230 DIM A(3,4), B(4,4), C(7)
	240 MAT A = CON
	250 MAT B = IDN
	260 ARR C = ZER1

In this special form, the target variable must already exist and have dimensions specified.

Statement modifiers
-------------------

Statements may be controlled with modifiers, clauses at the end that branch around the statement or perform it multiple times.
Statements may have zero, one, or multiple modifiers.
Modifiers are processed from right to left, with the last one on the line being processed first.

Modified statements
~~~~~~~~~~~~~~~~~~~

Some statements may have modifiers; others may not.
Statements that may have modifiers are:

CHANGE, CLOSE, FORGET, GOSUB, GOTO, INPUT, LET, (LET-less assignment), LINE INPUT, OPEN, PRINT, RANDOMIZE, READ, RESTORE, RETURN, SLEEP, STOP, WRITE, ARR, ARR FORGET, ARR PRINT, ARR READ, ARR WRITE, MAT, MAT FORGET, MAT PRINT, MAT READ, MAT WRITE

IF modifier
~~~~~~~~~~~

Conditional execution of the statement.

Examples:

	10 PRINT A IF B>0
	200 GOTO 10 IF A$="YES"
	240 GOSUB 800 IF C2=4

Notice that there is no 'THEN' clause for the IF modifier.
The modifier controls the action for just the one statement.

UNLESS modifier
~~~~~~~~~~~~~~~

Conditional execution of the statement.
Opposite of the IF modifier.
The main statement is executed when the condition is false.

Examples:

	10 PRINT A UNLESS B>0
	200 GOTO 10 UNLESS A$="YES"
	240 GOSUB 800 UNLESS C2=4

The modifier controls the action for just the one statement.

FOR modifier
~~~~~~~~~~~~

Repeated execution of the statement.

Examples:

	10 DIM A(10)
	20 A(I) = I FOR I = 1 TO 10
	100 PRINT A(I); FOR I = 1 TO 10
	100 PRINT A(I); FOR I = 1 TO 10 STEP 2

WHILE modifier
~~~~~~~~~~~~~~

Repeasted execution of the statement.

Examples:

	10 LET A = A + 1 WHILE A<10
	240 GOSUB 800 WHILE FNR(A)<>0

The modifier controls the action for just the one statement.

UNTIL modifier
~~~~~~~~~~~~~~

Repeated execution of the statement.

Examples:

	10 LET A = A + 1 UNTIL A<10
	240 GOSUB 800 UNTIL FNR(A)<>0

The modifier controls the action for just the one statement.

Combining modifiers
~~~~~~~~~~~~~~~~~~~

BASIC-1978 accepts multiple modifiers on a statement.

Example:

	100 PRINT A(I) IF I/2 = INT(I/2) FOR I = 1 TO 10

Modifiers are processed right-to-left, with the last modifier specified being executed first.
In the example, the FOR loop is processed first. Each iteration of the FOR loop processes the IF modifier.
If the expression for the IF modifier is true, the main statement is executed.

Editing programs
----------------

Programs may be edited externally and loaded with the LOAD command, and they may be entered and edited within BASIC-1978.

An entered line is parsed and either executed or stored as part of the program.
Lines that begin with numbers are considered part of the program; lines without numbers are executed immediately.

To replace a line, enter a line with the number of the old line.
You must enter the entire line; there are no 'line editing' capabilities.

Infinite loops
--------------

The interpreter detects infinite loops in some situations.
When it detects an infinite loop, it stops the program.
The detection algorithm is weak, and it will miss most infinite loops.
The detection algorithm is:

	keep a list of the line numbers for executed statements
	if the statement about to be executed is in the list, report an infinite loop
	when a variable is set to a new value (different than current value), clear the list
	INPUT, LINE INPUT, and READ statements (console or files) will also clear the list
	a statement which invokes the RND() function also clears the list

This algorithm will detect simple infinite loops such as

	10 PRINT "HELLO"
	20 GOTO 10

and

	10 LET A = 1
	20 IF A < 5 THEN 10

and

	10 GOTO 10

and also

	10 FOR I = 1 TO 10 STEP 0


The detection algorithm is not perfect, and it is easy to write a program with an infinite loop that evades detection:

    	10 LET A = 1
	20 PRINT A
	30 LET A = A + 1
	40 GOTO 20
	99 END

The algorithm may detect false positives - infinite loops when none exist.
The DETECT_INFINITE_LOOP option, when set to FALSE, disables checks for infinite loops.

File format
~~~~~~~~~~~

Source files
^^^^^^^^^^^^

Source files are stored in ASCII.

Source files contain three groups of line: options, source, and breakpoints.
Option lines begin with the keyword '.OPTION'.
Source lines begin with a line number.
Breakpoint lines begin with the keyword '.BREAK'

Other lines are considered errors.

There is no continuation of lines.

Data files
^^^^^^^^^^

Data files are stored in ASCII.

Data files consist of lines of text, and each line of text consists of fields.
Fields are separated by delimiters, which may be ',' or ';'.
The WRITE statement inserts delimiters.
The PRINT statement does not insert delimiters.
To write a file in BASIC and then read that file in BASIC, use WRITE statements or PRINT statements with delimiters between fields.

To write the file:

100 WRITE #1, A, B, C
110 PRINT #1, A; ","; B; ","; C

To read the file

200 READ #2, A, B, C
210 INPUT #2, A, B, C

Error codes
-----------

1	BREAK

10	Invalid statement
11	Invalid statement in function
12	Program terminated without END
13	Line number not found
14	Line index out of range
15	Cannot CHAIN due to error in target program

20	DIM statement requires subscripts
21	GOSUB without RETURN
22	RETURN without GOSUB
23	FOR without NEXT
24	NEXT without FOR
25	Implied NEXT without FOR

31	RESUME without error
32	Infinite loop detected
33	Bad expression

40	No print format
41	Too few items for print format

50	Uninitialized variable
51	Cannot change locked variable

60	Invalid type for boolean
61	Invalid type for integer
62	Invalid type for float
63	Invalid type for string
69	Unknown value type

70	Types not compatible

80	Invalid operator
81	Text is not a number

90	Divide by zero
91	Value below minimum
92	Value above maximum

100	Variable has no dimensions
101	Incorrect number of subscripts
102	Subscript out of range

110	Source is not an array
111	Array must have 1 dimension
112	Need dimension for array
113	Too many dimensions for array

120	Source is not a matrix
121	Matrix must have 1 or 2 dimensions
122	Need dimensions for matrix
123	Too many dimensions for matrix

130	Value list is empty
131	Too few items
132	Not enough values

140	Function not defined
141	Function requires arguments
142	Function requires string with content
143	Invalid value for argument
144	Wrong count
145	Wrong arguments for function
146	Function requires array argument
147	Function requires matrix argument
148	Function requires square matrix argument

150	Invalid transfer in/out of user function

102	Value is not assignable

160	Out of data

170	Invalid file reference
171	Invalid file number
172	Invalid file name
173	File not found
174	Invalid file handle
175	Unknown file handle
176	Invalid input
177	End of file
178	Invalid file mode
179	Inconsistent file operation
